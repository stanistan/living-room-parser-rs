// There should only be *one* main entry function.
//
// The organization of this grammar is top-level -> down,
// so that the last rules should be literals/terminals
// and the top first rule is the public/exported main
// `parse` function.

pub parse -> Terms = ts:term* {
    Terms(ts)
}

term -> Term
    = value / hole / id / variable / wildcard / ws / word

value -> Term
    = float / int / null / boolean / string

string -> Term
    = "\"" s:$(!"\"" !"\n" .)* "\"" {
        Term::String(s.to_owned())
    }

word -> Term
    = w:$(word_pattern+) ![0-9] {
        Term::Word(w.to_owned())
    }
    / w:$(word_char+) {
        Term::Word(w.to_owned())
    }

int -> Term
    = "0" { Term::Int(0) }
    / s:$([-+]?[1-9]digit*) {
        Term::Int(i64::from_str(s).unwrap())
    }

float -> Term
    = s:$( [-+]? digit* frac exp? ) {
        Term::Float(f64::from_str(s).unwrap())
    }
    / s:$( [-+]? frac exp?) {
        Term::Float(f64::from_str(s).unwrap())
    }

null -> Term
    = "null" { Term::Null }

boolean -> Term
    = "true" {
        Term::Bool(true)
    }
    / "false" {
        Term::Bool(false)
    }

id -> Term
    = "#" w:$(alnum*) {
        Term::Id(w.to_owned())
    }

variable -> Term
    = "$" w:$(alnum+) {
        Term::Variable(w.to_owned())
    }

ws -> Term
    = whitespace+ {
        Term::Whitespace
    }

hole -> Term
    = "_" {
        Term::Hole
    }

wildcard -> Term
    = "$" {
        Term::Wildcard
    }

alnum = digit / character
word_delimiter = "$" / "#" / "_" / whitespace / digit
word_char = [^# $ 0-9 _ . "]
word_pattern = word_char+ "."+

exp = ("e" / "E") ("-" / "+")? digit*<1,>
frac = "." digit*<1,>

whitespace = "\n" / " " / "\n\r" / "\t"
digit = [0-9]
character = [a-zA-Z]
